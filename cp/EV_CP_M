import sys
import time
import socket
import threading

def parse_host_port(hostport):
    try:
        host, port = hostport.split(":")
        return host, int(port)
    except Exception:
        raise ValueError("Formato inválido. Usa IP:PUERTO, ej. 127.0.0.1:6001")

def enviar_linea(addr, texto, timeout=1.0):
    host, port = parse_host_port(addr)
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            s.sendall((texto.strip() + "\n").encode("utf-8"))
            s.settimeout(timeout)
            _ = s.recv(64)
            return True
    except Exception:
        return False

def ping_engine(engine_addr, timeout=1.0):
    host, port = parse_host_port(engine_addr)
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            s.sendall(b"PING\n")
            s.settimeout(timeout)
            resp = s.recv(16).decode("utf-8", errors="ignore").strip().upper()
            return resp == "OK"
    except Exception:
        return False

def enviar_cmd_engine(engine_addr, texto, timeout=1.0):
    return enviar_linea(engine_addr, texto, timeout=timeout)

def enviar_central(central_addr, texto, timeout=1.0):
    return enviar_linea(central_addr, texto, timeout=timeout)

def monitorizar(engine_addr, central_addr, cp_id):
    ultimo_ok = ping_engine(engine_addr) 

    while True:
        ok = ping_engine(engine_addr)
        if ultimo_ok and not ok:
            print("[EV_CP_M] AVERIA detectada (PING=KO) -> notificar a Central")
            enviar_central(central_addr, f"MON_AVERIA {cp_id}")
        elif (not ultimo_ok) and ok:
            print("[EV_CP_M] RECUPERACION detectada (PING=OK) -> notificar a Central")
            enviar_central(central_addr, f"MON_RECUPERADO {cp_id}")
        ultimo_ok = ok
        time.sleep(1.0)


def bucle_teclado(engine_addr):
    try:
        while True:
            cmd = input().strip().lower()
            if cmd in ("failon", "failoff"):
                ok = enviar_cmd_engine(engine_addr, "FAILON" if cmd == "failon" else "FAILOFF")
                print(f"[EV_CP_M] {cmd} -> {'OK' if ok else 'ERROR'}")
            elif cmd == "status":
                ok = enviar_cmd_engine(engine_addr, "STATUS")
                print(f"[EV_CP_M] status -> {'OK' if ok else 'ERROR'}")
            else:
                print("[EV_CP_M] Comandos válidos: failon, failoff, status")
    except KeyboardInterrupt:
        return

def main():
    if len(sys.argv) < 4:
        print("Uso: python EV_CP_M.py <IP:PUERTO_ENGINE> <IP:PUERTO_CENTRAL> <CP_ID>")
        sys.exit(1)

    engine_addr  = sys.argv[1]
    central_addr = sys.argv[2]
    cp_id        = sys.argv[3]

    for a in (engine_addr, central_addr):
        try:
            parse_host_port(a)
        except ValueError as e:
            print(f"[EV_CP_M] {e}")
            sys.exit(1)

    print(f"[EV_CP_M] Monitor iniciado. CP_ID={cp_id} | Engine={engine_addr} | Central={central_addr}")

    ok = enviar_central(central_addr, f"HELLO {cp_id}")
    print(f"[EV_CP_M] HELLO Central -> {'OK' if ok else 'ERROR'}")

    hilo_mon = threading.Thread(target=monitorizar, args=(engine_addr, central_addr, cp_id), daemon=True)
    hilo_mon.start()
    print("[EV_CP_M] Heartbeat activo: PING cada segundo.")

    hilo_tecl = threading.Thread(target=bucle_teclado, args=(engine_addr,), daemon=True)
    hilo_tecl.start()
    print("[EV_CP_M] Opcional: escribe 'failon'/'failoff'/'status' y Enter para probar con el Engine.")

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n[EV_CP_M] Saliendo...")

if __name__ == "__main__":
    main()
